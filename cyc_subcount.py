#lcm returns the least common multiple of multiple inputs

from math import lcm

#gcd returns the greatest common divisor between multiple inputs.

from math import gcd

# totient (named after the Euler totient function) sifts through
# a defined range and finds values strictly less than the input which
# have gcd(v, k) = 1. It then totals the number of values and returns
# that total.

def totient(v):
    total = 0
    for a in range(1, v + 1):
        if gcd(a, v) == 1:
            total = total + 1
    return total

# factorsof takes in an input an returns an ordered list
# of factors of the input (e.g. factorsof(12) = [1,2,3,4,6,12])

def factorsof(v):
    listofdiv = [k for k in range(1, v + 1) if not v % k]
    return listofdiv

# v1 = order of first group, v2 = order of second group, 
# and v3 = order of the subgroups you're attempting to count.

# el pairs takes in the variables v1, v2 defined above and calls the 
# factorsof function for both values. It then chooses pairs of numbers
# from those lists that satisfy lcm = v3 and returns an ordered list
# containing those pairs.


def elpairs(v1, v2, v3):
    listofcases = []
    list1  = factorsof(v1)
    list2 = factorsof(v2)
    for s in list1:
        for t in list2:
            if lcm(s,t) == v3:
                listofcases.append((s,t))
    return listofcases

#elcountlist calls listofdiv for three and searches for pairs of numbers in 
# the divisors of v1 and v2 which produce lcm = v3.
# elcountlist then calls rel on each number in a pair and multiplies them.
# These values are then added to a bracketed list 
# (e.g. [((totient(1)*totient(5)), (totient(5)*totient(1)), 
# (totient(5)*totient(5))]


def elcountlist(v1, v2, v3):
    listofcases = []
    list1 = elpairs(v1, v2, v3)
    for (i, k) in list1:
        listofcases.append(totient(i)*totient(k))
    return listofcases

#elcount adds the elements of the list returned by elcountlist together
#(e.g. (totient(1)*totient(5))+(totient(5)*totient(1))+(totient(5)*totient(5)))


def elcount(v1, v2, v3):
    list1 = elcountlist(v1, v2, v3)
    total = 0
    for l in list1: 
        total = total + sum(list1)
        break
    return total

#cycsubcount calls both elcount and totient and divides the former by the latter 
# to give you the number of cyclic subgroups.

def cycsubcount(v1, v2, v3):
    total  =  elcount(v1, v2, v3)//totient(v3)
    return total

# I recently added some functions where you can play around with groups 
# under modulo n addtion

# Z(n) takes in the order of the group you'd like to generate under 
# modulo n additon and places the elements of the group in an ordered
# list.

def Z(n):
    elements = []
    for i in range(0, n):
        for l in range(0, n):
            op = (i + l % n)
            elements.append(op)
            break
    return elements

# The original prupose of genZ was to create the cyclic
# subgroup generated by a single element that has the same order
# as the original group. It serves the purpose of combining any
# element you choose under the specified modulo base.
# (e.g. genZ(4,2) = [2,0])

def genZ(n, a):
    elements = []
    x = a % n
    elements.append(x)
    while True:
        x = (x + a) % n
        if x in elements:
            break
        else:
            elements.append(x)
    return elements

# whatisgen takes in the order of a group Z(n) and will tell you
# what set of numbers you can combine with themselves and get the 
# whole group back, and which elements you cannot. It's a fun tool.

def whatisgen(v):
    list1 = []
    list2 = []
    for i in range(1, v):
        if gcd(v, i) == 1:
            list1.append(i)
        elif gcd(v, i) != 1:
            list2.append(i)
    return list1, list2

# Feel free to leave me suggestions of some finite group theory stuff
# I am always looking to challenge myself as it helps me learn
#the subject better anyway.