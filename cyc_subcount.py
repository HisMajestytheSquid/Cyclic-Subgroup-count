#lcm returns the least common multiple of multiple inputs

from math import lcm

#gcd returns the greatest common divisor between multiple inputs.

from math import gcd


# totient (named after the Euler totient function) sifts through
# a defined range and finds values strictly less than the input which
# have gcd(v, k) = 1. It then totals the number of values and returns
# that total.

def totient(N):
    # Setting initial number of totatives to N
    ans = N;
    i = 2 
    while (i*i <= N) :
        if (N % i == 0) :
            ans = (ans - int(ans/i));
        while (N % i == 0) :
            N = N/i;
        i += 1
    if(N > 1): 
        ans = ans - int(ans/N);
    return int(ans);

# factorsof takes in an input an returns an ordered list
# of factors of the input (e.g. factorsof(12) = [1,2,3,4,6,12])

def factorsof(_value_):
    listofdiv = [k for k in range(1, _value_ + 1) if not _value_ % k]
    return listofdiv

# v1 = order of first group, v2 = order of second group, 
# and v3 = order of the subgroups you're attempting to count.

# elpairs takes in the variables v1, v2 defined above and calls the 
# factorsof function for both values. It then chooses pairs of numbers
# from those lists that satisfy lcm = v3 and returns an ordered list
# containing those pairs.


def elpairs(group_order_1, group_order_2, element_order):
    listofcases = []
    list1  = factorsof(group_order_1)
    list2 = factorsof(group_order_2)
    for s in list1:
        for t in list2:
            if lcm(s,t) == element_order:
                listofcases.append((s,t))
    return listofcases

#elcountlist calls listofdiv for three and searches for pairs of numbers in 
# the divisors of v1 and v2 which produce lcm = v3.
# elcountlist then calls rel on each number in a pair and multiplies them.
# These values are then added to a bracketed list 
# (e.g. [((totient(1)*totient(5)), (totient(5)*totient(1)), 
# (totient(5)*totient(5))]


def elcountlist(group_order_1, group_order_2, element_order):
    listofcases = []
    list1 = elpairs(group_order_1, group_order_2, element_order)
    for (i, k) in list1:
        listofcases.append(totient(i)*totient(k))
    return listofcases

#elcount adds the elements of the list returned by elcountlist together
#(e.g. (totient(1)*totient(5))+(totient(5)*totient(1))+(totient(5)*totient(5)))


def elcount(group_order_1, group_order_2, element_order):
    list1 = elcountlist(group_order_1, group_order_2, element_order)
    total = 0
    for l in list1: 
        total = total + sum(list1)
        break
    return total

#cycsubcount calls both elcount and totient and divides the former by the latter 
# to give you the number of cyclic subgroups.

def cycsubcount(group_order_1, group_order_2, element_order):
    total  =  elcount(group_order_1, group_order_2, element_order)//totient(element_order)
    return total

# I recently added some functions where you can play around with groups 
# under modulo n addtion

# Z(n) takes in the order of the group you'd like to generate under 
# modulo n additon and places the elements of the group in an ordered
# list.

def Z(_group_order_):
    elements = []
    for i in range(0, _group_order_):
        for l in range(0, _group_order_):
            op = (i + l % _group_order_)
            elements.append(op)
            break
    return elements

# The original prupose of genZ was to create the cyclic
# subgroup generated by a single element that has the same order
# as the original group. It serves the purpose of combining any
# element you choose under the specified modulo base.
# (e.g. genZ(4,2) = [2,0])

def genZ(_group_order_, _generating_element_):
    elements = []
    x = _generating_element_ % _group_order_
    elements.append(x)
    while True:
        x = (x + _generating_element_) % _group_order_
        if x in elements:
            break
        else:
            elements.append(x)
    return elements

# whatisgen takes in the order of a group Z(n) and will tell you
# what set of numbers you can combine with themselves and get the 
# whole group back, and which elements you cannot. It's a fun tool.

def whatisgen(_group_order_):
    list1 = []
    list2 = []
    for i in range(1, _group_order_):
        if gcd(_group_order_, i) == 1:
            list1.append(i)
        elif gcd(_group_order_, i) != 1:
            list2.append(i)
    return list1, list2

# ZoZ takes in the order of two groups under modulo n (and m) addition in the integers and lets you find
# the external direct product of them. Incidently, this is the kind of group the cycsubcount is counting 
# element from. Is was a goal of mine to finally be able to do this. 

def ZoZ(group_order_1, group_order_2):
    elements = []
    list1 = Z(group_order_1)
    list2 = Z(group_order_2)
    for i in list1:
        for k in list2:
            elements.append((i, k))
    return elements

# orderofelementZ seems self explanatory but for those not in the know, the order of an element in a group
# is howmany times it can be combined with itself before to are taken back to the identity.
# So, orderofelement(4,2) = 2 means that in the groups of integers under addition modulo 4, the order of 2
# is 2.

def orderofelementZ(_group_order_, _generating_element_):
    i = genZ(_group_order_, _generating_element_)
    order = len(i)
    return order

# findinverseZ finds the element in the group that gives you the identity in the specified group when combined 
# with the specified element.

def findinverseZ(_group_order_, element):
    i = (orderofelementZ(_group_order_, element) - 1)
    inverse = (element*i % _group_order_)
    return inverse

# This is a pretty niche function thatr was used primarily for identifying what coefficients will work for 
#homomorphisms fomr Zm to Zn.

def find_generating_elements(_orderfirst_, v):
    elements = []
    for i in range(1, _orderfirst_):
        if gcd(_orderfirst_, i) == v:
            elements.append(i)
            return elements

# homomorphism was created mostly as a way to make my homework easier. The process used the factor group of 
# Zm/_generating_element_to find the list of values that mapped to a specific value in Zn under a homomorphism
# from Zm to Zn. Essentially this was used to check that I found the correct pullback. The example in the HW was
# a homomorphic mapping from Z(50) to Z(15) and you wanted to find all the elements of Z(50) which mapped to 
# 3 in Z(15).
   
def homomorphism(_orderfirst_, _ordersecond_, _generating_element_, _homocoeff_, _coset_rep_):
    list1 = genZ(_orderfirst_, _generating_element_)
    elements = []
    for i in list1:
        value = (_homocoeff_*(i + _coset_rep_)) % _ordersecond_
        elements.append(value)
    return elements

# U(_modbase_) will just give you the group of units under modulo whatever multiplication.

def U(_modbase_):
    x = Z(_modbase_)
    elements = []
    for i in x:
        if gcd(_modbase_, i) == 1:
            elements.append(i)
    return elements

# genU serves a similar purpose to genZ only it uses the multiplication mod something operation rather than addition.

def genU(_modbase_, _generatingelement_):
    elements = []
    x = (_generatingelement_ % _modbase_)
    while True:
        x = (x * _generatingelement_) % _modbase_
        if x in elements:
            break
        elif gcd(x, _modbase_) != 1:
            break
        else:
            elements.append(x)
    return elements

# orderofelementU gives you the order of an element in the group of units under modulo something multiplication

def orderofelementU(_modbase_, _element_):
    x = genU(_modbase_, _element_)
    order = len(x)
    return order

# findinverseU will find the element in the groups of units that when combined with _element_ gives you the identity.

def findinverseU(_modbase_, _element_):
    i = orderofelementU(_modbase_, _element_)
    x = (i - 1)
    inverse = ((_element_)**x) % _modbase_
    if i < 1:
        return None
    else:
        return inverse

#There is going to be a lot of veteran coders that really gonna *really* hate the next two but I got tired of calling 
# genU and genZ to print each list of elements one by one. So I made two functions that give you all the subgroups 
# generated by each element in each group. Give genUlists(10) and genZlists(10) a try.

def genUlists(n):
    list1 = U(n)
    for i in list1:
     print("<",i,">", "=", genU(n, i))
    return 

def genZlists(n):
    list1 = Z(n)
    for i in list1:
        print("<",i,">", "=", genZ(n, i))
    return

genUlists(10)

genZlists(10)
